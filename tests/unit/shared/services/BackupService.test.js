// @ts-nocheck
const { BackupService } = require('../../../../shared/services/BackupService');
const { TextEncoder } = require('util');
global.TextEncoder = TextEncoder;

// Mock global chrome object
global.chrome = {
  storage: {
    local: {
      get: jest.fn(),
      set: jest.fn(),
      clear: jest.fn(),
    },
  },
  downloads: {
    download: jest.fn((options, callback) => callback && callback(123)),
  },
  runtime: {
    getManifest: jest.fn(() => ({ version: '2.10.0' })),
  },
};

Object.defineProperty(global, 'crypto', {
  value: {
    subtle: {
      digest: jest.fn().mockResolvedValue(new ArrayBuffer(32)),
    },
  },
  writable: true,
});

global.URL = {
  createObjectURL: jest.fn(() => 'blob:mock-url'),
  revokeObjectURL: jest.fn(),
};

global.Blob = class {
  constructor(content, options) {
    this.content = content;
    this.options = options;
  }
};

describe('BackupService', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('exportData', () => {
    it('should export all data with metadata', async () => {
      // Arrange
      const mockData = { courses: { 1: { id: 1 } }, settings: { density: 'compact' } };
      chrome.storage.local.get.mockResolvedValue(mockData);

      const realDate = Date.now;
      global.Date.now = jest.fn(() => 1735689600000); // Fixed timestamp

      // Act
      await BackupService.exportData();

      // Assert
      expect(chrome.storage.local.get).toHaveBeenCalledWith(null);

      // Verify Blob creation and content
      expect(global.URL.createObjectURL).toHaveBeenCalledTimes(1);
      const blob = global.URL.createObjectURL.mock.calls[0][0];

      expect(blob).toBeInstanceOf(global.Blob);
      expect(blob.options).toEqual({ type: 'application/json' });

      const jsonString = blob.content[0]; // Blob content is array of parts
      const exported = JSON.parse(jsonString);

      expect(exported).toEqual({
        data: mockData,
        meta: {
          version: '2.10.0',
          exportedAt: '2025-01-01T00:00:00.000Z', // Timestamp 1735689600000 is 2025
          schemaVersion: 1,
          checksum: '0000000000000000000000000000000000000000000000000000000000000000', // Mocked 32 zero-bytes
        },
      });

      // Verify Download trigger
      expect(chrome.downloads.download).toHaveBeenCalledTimes(1);
      const downloadCall = chrome.downloads.download.mock.calls[0][0];
      expect(downloadCall.url).toBe('blob:mock-url');
      expect(downloadCall.filename).toMatch(/univesp-backup-\d{4}-\d{2}-\d{2}\.json/);

      // Restore Date
      global.Date.now = realDate;
    });
  });

  describe('importData', () => {
    it('should successfully import valid data', async () => {
      // Arrange
      // Default mock returns 32 bytes of zeros
      const expectedHash = new Uint8Array(32)
        .fill(0)
        .reduce((acc, val) => acc + val.toString(16).padStart(2, '0'), '');

      const validJson = JSON.stringify({
        meta: { version: '2.9.0', schemaVersion: 1, checksum: expectedHash },
        data: { courses: { 2: { id: 2 } } },
      });

      // Act
      const result = await BackupService.importData(validJson);

      // Assert
      expect(result.success).toBe(true);
      expect(chrome.storage.local.clear).toHaveBeenCalled();
      expect(chrome.storage.local.set).toHaveBeenCalledWith({ courses: { 2: { id: 2 } } });
    });

    it('should reject invalid json string', async () => {
      const result = await BackupService.importData('invalid-json-{');
      expect(result.success).toBe(false);
      expect(result.error).toContain('JSON incompleto');
      expect(chrome.storage.local.set).not.toHaveBeenCalled();
    });

    it('should reject missing data key', async () => {
      const invalidSchema = JSON.stringify({ meta: {} }); // Missing data
      const result = await BackupService.importData(invalidSchema);
      expect(result.success).toBe(false);
      expect(result.error).toContain('Esquema invÃ¡lido');
      expect(chrome.storage.local.set).not.toHaveBeenCalled();
    });

    it('should fail if checksum is missing', async () => {
      const invalidPayload = JSON.stringify({
        meta: { version: '2.10.0', schemaVersion: 1 }, // No checksum
        data: { foo: 'bar' },
      });

      const result = await BackupService.importData(invalidPayload);
      expect(result.success).toBe(false);
      expect(result.error).toContain('integridade');
    });

    it('should fail if checksum does not match', async () => {
      // Mock crypto to return a DIFFERENT hash than what's in the payload
      // Expected by payload: 'original-hash'
      // Generated by mock: 010203... (from [1, 2, 3])

      global.crypto.subtle.digest.mockResolvedValueOnce(new Uint8Array([1, 2, 3]).buffer);

      const tamperedPayload = JSON.stringify({
        meta: { version: '2.10.0', schemaVersion: 1, checksum: 'original-hash' },
        data: { foo: 'bar-tampered' },
      });

      const result = await BackupService.importData(tamperedPayload);
      expect(result.success).toBe(false);
      expect(result.error).toContain('corrompido');
    });
  });
});
